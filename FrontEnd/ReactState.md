# **React에서 상태란?**

- 컴포넌트 간에 이동되는 `props`와 달리 컴포넌트 내부에서 관리되는 자바스크립트 객체
- 어플리케이션의 화면 렌더링에 영향을 끼친다
- 사용자의 인터랙션을 통해 **동적으로 변하는** 데이터

### **관리 해야 하는 상태의 기준은?**

- 서로 다른 컴포넌트에서 동일한 데이터를 다룰 때!

### **그럼 이럴 땐 상태를 왜 관리해줘야 하나요**

- 서로 다른 컴포넌트에서 동일한 데이터를 다룰 땐, 해당 데이터의 출처가 동일해야 한다. 그래야 서로의 변화에 동적으로 반응할 수 있기 때문이다.
- 즉 상태의 일관성 (=”데이터의 무결성”)을 잘 지켜야한다.
- “Single Source of Truth”이라는 방법론이 이러한 상태의 일관성을 유지하기 위해 등장한 방법론인데, 말그대로 신뢰할 수 있는 **단일 출처**를 말한다. 이 방법론이 React가 택한 방법론으로, 결국 React에서 상태관리가 필요한 이유는 데이터의 무결성을 위해서, 서로 다른 컴포넌트에 분포되어있는 하나의 데이터가 서로 일치할 수 있도록 관리해주기 위함이다.

## **상태의 종류**

- 지역 상태 : 컴포넌트 내부에서만 관리되는 상태
  - ex) Input을 통해 사용자 입력을 받아 상태를 업데이트하는 경우
- 컴포넌트 간 상태 : 여러 컴포넌트를 넘나들며 관리되는 상태
  - 부모 컴포넌트에서 자식 컴포넌트로 prop를 통해 전달한다 → 연속될 경우 “Prop Drilling”
  - ex) Modal창
- 전역 상태 : 프로젝트 전체에 영향을 끼치는 상태

### **Prop Drilling?**

- props를 다른 컴포넌트로 전달하기 위해서 여러가지 컴포넌트를 거치는 방식을 말한다.
- 부모 컴포넌트 → 중간 컴포넌트1 → 중간 컴포넌트 2→ … → 최종 컴포넌트
- 부모 컴포넌트에서 최종 컴포넌트로 props를 전달하기 위해 중간 컴포넌트들을 거친다.
- 이 depth가 깊어질 수록 상태를 추적하기 어려워지기 때문에 무조건 Prop Drilling으로 props들을 불필요한 컴포넌트들을 거치도록 하지 않고 별도의 상태관리가 꼭 필요하다.

## 리액트 렌더링을 관리하여 성능을 최적화하는 방법 알아보기

### 1. useMemo

- useMemo는 종속 변수들이 변하지 않으면 함수를 굳이 다시 호출하지 않고 이전에 반환한 참조값을 재사용 한다.
- 즉, 함수 호출 시간도 세이브할 수 있고 같은 값을 props로 받는 하위 컴포넌트의 리렌더링도 방지할 수 있다.

### 2. **React.memo 컴포넌트 메모이제이션**

- React hook이 아니라서 클래스형 컴포넌트에서도 사용할 수 있다.
- React.memo를 통해 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화 해줄 수 있다.
- 콜백함수를 이용해 메모이제이션을 적용할지 여부를 판단할 수도 있다

### **3. useCallback**

- useMemo가 리턴되는 값을 memoize 시켜주었는데, useMemo와 비슷한 useCallback은 **함수 선언을 memoize 하는데 사용된다**
- useCallback으로 함수를 선언해주면, 종속 변수들이 변하지 않는 이상 굳이 함수를 재생성하지 않고 이전에 있던 참조 변수를 그대로 하위 컴포넌트에 props로 전달하여, 하위 컴포넌트도 props가 변경되지 않았다고 인지하게 되어 하위 컴포넌트의 리렌더링을 방지할 수 있다.

### **4. 자식 컴포넌트의 props로 객체를 넘겨줄 경우 변형하지말고 넘겨주기**

- props의 값으로 객체를 넘겨주는 경우 새로 생성된 객체가 props로 들어가므로 컴포넌트가 리렌더링 될 때마다 새로운 객체가 생성되어 자식 컴포넌트로 전달된다.
- props로 전달한 객체가 동일한 값이어도 새로 생성된 객체는 이전 객체와 다른 참조 주소를 가진 객체이기 때문에 자식 컴포넌트는 메모이제이션이 되지않는다.
- 생성자 함수나 객체 리터럴로 객체를 생성해서 하위 컴포넌트로 넘겨주는 방식이 아닌, state를 그대로 하위컴포넌트에 넘겨주어 필요한 데이터 가공을 그 하위컴포넌트에서 해주는 것이 좋다.

### **5. 컴포넌트를 매핑할 때에는 key값으로 index를 사용하지 않는다.**

- 리액트에서 매핑을 할때 반드시 고유 key를 부여하도록 강제하고 있는데, 배열의 index값으로 key값을 부여하면 좋지 않다.
- 왜냐하면, 어떤 배열에 중간에 어떤 요소가 삽입될때 그 중간 이후에 위치한 요소들은 전부 index가 변경된다.
- 이로 인해 key값이 변경되어 React는 key가 동일 할 경우, 동일한 DOM Element를 보여주기 때문에 예상치 못한 문제가 발생한다. 또한, 데이터가 key와 매치가 안되어 서로 꼬이는 부작용도 발생한다.

### **6. useState의 함수형 업데이트**

- setState를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수도 있는데,

이렇게 하면 useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 값을 넣어주지 않아도 된다.

```jsx
// 예시) 삭제 함수
const onRemove = useCallback(
  (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  },
  [todos]
);

// 예시) 함수형 업데이트 후
const onRemove = useCallback((id) => {
  setTodos((todos) => todos.filter((todo) => todo.id !== id));
}, []);
```

### **7. Input에 onChange 최적화**

- 보통 input 태그에 onChange 이벤트를 줄때 타이핑을 할때마다 해당 컴포넌트가 렌더링 되어, 최적화 방법을 많이 찾곤한다.
- lodash 라고 최적화 라이브러리를 쓰기도 하는데, 아래 코드는 라이브러리를 쓰지 않고 최적화 시킬수 있는 방법이다.

```jsx
// 예시) 최적화 전(X)
//UserList.jsx
function UserList() {
 {...}
  return (
      <div>
       <input
         type="text"
         value={text}
         placeholder="아무 내용이나 입력하세요."
         onChange={(event) => setText(event.target.value)}
        />
   {...}
      </div>
  );
}

export default UserList;

// 예시) 최적화 후(O)
//UserList.jsx
function UserList() {
 {...}
  return (
      <div>
       <input
          ref={searchRef}
          type="text"
          placeholder="아무 내용이나 입력하세요."
          onKeyUp={() => {
            let searchQuery = searchRef.current.value.toLowerCase();
            setTimeout(() => {
              if (searchQuery === searchRef.current.value.toLowerCase()) {
                setText(searchQuery);
              }
            }, 400);
          }}
        />
   {...}
      </div>
  );
}

export default UserList;
```
